/* $Id: e67e3079fc342154fce540f31a263151797d8350 $
 * 
 * Part of ZonMW project no. 50-53000-98-156
 * 
 * @license
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 * 
 * Copyright (c) 2016 RIVM National Institute for Health and Environment 
 */
package nl.rivm.cib.episim.model;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListMap;

import javax.measure.quantity.Dimensionless;
import javax.measure.quantity.Frequency;

import org.jscience.physics.amount.Amount;

import io.coala.exception.ExceptionFactory;
import io.coala.time.x.Instant;
import nl.rivm.cib.episim.time.Accumulator;
import nl.rivm.cib.episim.time.Scheduler;
import nl.rivm.cib.episim.time.Timed;
import rx.Observable;
import rx.Observer;
import rx.subjects.PublishSubject;
import rx.subjects.Subject;

/**
 * {@link TransmissionSpace}
 * 
 * @version $Id: e67e3079fc342154fce540f31a263151797d8350 $
 * @author Rick van Krevelen
 */
public interface TransmissionSpace extends Timed
{

	Collection<TransmissionRoute> getTransmissionRoutes();

	/**
	 * @return an {@link Observable} stream of {@link ContactEvent}s generated
	 *         by {@link Carrier} occupants of this {@link TransmissionSpace}
	 */
	Observable<ContactEvent> emitContacts();

	/**
	 * @return an {@link Observable} stream of {@link TransmissionEvent}s
	 *         generated by {@link Carrier} occupants of this
	 *         {@link TransmissionSpace}
	 */
	Observable<TransmissionEvent> emitTransmissions();

	/**
	 * @param infection the local {@link Infection}
	 * @return the respective {@link InfectionDynamics}
	 */
	InfectionDynamics dynamicsOf( Infection infection );

	/**
	 * @param visitor the {@link Carrier} arriving at this
	 *            {@link TransmissionSpace}
	 */
	default void enter( final Carrier visitor )
	{
		visitor.getConditions().forEach( ( infection, condition ) ->
		{
			dynamicsOf( infection ).dynamicsOf( condition.getCompartment() )
					.onEnter( visitor );
		} );
	}

	/**
	 * @param visitor the {@link Carrier} leaving this {@link TransmissionSpace}
	 */
	default void leave( final Carrier visitor )
	{
		visitor.getConditions().forEach( ( infection, condition ) ->
		{
			dynamicsOf( infection ).dynamicsOf( condition.getCompartment() )
					.onLeave( visitor );
		} );
	}

	/**
	 * {@link Carrier}s staying at this {@link TransmissionSpace} may cause it
	 * to generate {@link ContactEvent}s and {@link TransmissionEvent}s based on
	 * available {@link TransmissionRoute}s (e.g. contaminated objects, food,
	 * water, blood, ...)
	 * 
	 * @param visitor the temporary occupant {@link Carrier}
	 * @param arrival the {@link Instant} of arrival
	 * @param departure the {@link Instant} of departure
	 */
	default void stay( final Carrier visitor, final Instant arrival,
		final Instant departure )
	{
		at( arrival ).call( this::enter, visitor );
		at( departure ).call( this::leave, visitor );
	}

	/**
	 * @return a {@link Simple} instance of {@link TransmissionSpace}
	 */
	static TransmissionSpace of( final Scheduler scheduler,
		final TransmissionRoute... routes )
	{
		return new Simple( scheduler, routes );
	}

	/**
	 * {@link SimpleInfection} is a {@link Infection} and {@link Observer} of
	 * {@link ContactEvent}s which in turn may trigger its transmission by
	 * generating {@link TransmissionEvent}s.
	 * 
	 * @version $Id: e67e3079fc342154fce540f31a263151797d8350 $
	 * @author Rick van Krevelen
	 */
	class Simple implements TransmissionSpace
	{

		private final Scheduler scheduler;

		private final Collection<TransmissionRoute> routes;

		private final Map<Infection, InfectionDynamics> infections = new ConcurrentHashMap<>();

		private final transient Subject<ContactEvent, ContactEvent> contacts = PublishSubject
				.create();

		private final transient Subject<TransmissionEvent, TransmissionEvent> transmissions = PublishSubject
				.create();

		public Simple( final Scheduler scheduler,
			final TransmissionRoute... routes )
		{
			this.scheduler = scheduler;
			this.routes = routes == null ? Collections.emptyList()
					: Arrays.asList( routes );
		}

		@Override
		public Scheduler scheduler()
		{
			return this.scheduler;
		}

		@Override
		public Collection<TransmissionRoute> getTransmissionRoutes()
		{
			return routes;
		}

		@Override
		public InfectionDynamics dynamicsOf( final Infection infection )
		{
			synchronized( this.infections )
			{
				InfectionDynamics result = this.infections.get( infection );
				if( result == null )
				{
					result = InfectionDynamics.of( this, infection );
					this.infections.put( infection, result );
				}
				return result;
			}
		}

		@Override
		public Observable<ContactEvent> emitContacts()
		{
			return this.contacts.asObservable();
		}

		@Override
		public Observable<TransmissionEvent> emitTransmissions()
		{
			return this.transmissions.asObservable();
		}
	}

	/**
	 * {@link InfectionDynamics}
	 * 
	 * @version $Id$
	 * @author Rick van Krevelen
	 */
	interface InfectionDynamics
	{
		TransmissionSpace getSpace();

		Infection getInfection();

		//Indicator getPressure();

		CompartmentDynamics dynamicsOf( EpidemicCompartment compartment );

		/**
		 * @param location the {@link TransmissionSpace}
		 * @param infection the {@link Infection}
		 * @return a {@link Simple} instance of {@link InfectionDynamics}
		 */
		static InfectionDynamics of( final TransmissionSpace location,
			final Infection infection )
		{
			return new Simple( location, infection );
		}

		/**
		 * {@link Simple} default implementation of {@link InfectionDynamics}
		 * 
		 * @version $Id$
		 * @author Rick van Krevelen
		 */
		class Simple implements InfectionDynamics
		{
			private TransmissionSpace location;

			private Infection infection;

			private final Map<EpidemicCompartment, CompartmentDynamics> compartments = new ConcurrentSkipListMap<>();

			public Simple( final TransmissionSpace location,
				final Infection infection )
			{
				this.location = location;
				this.infection = infection;
			}

			@Override
			public TransmissionSpace getSpace()
			{
				return this.location;
			}

			@Override
			public Infection getInfection()
			{
				return this.infection;
			}

			@Override
			public CompartmentDynamics
				dynamicsOf( final EpidemicCompartment compartment )
			{
				synchronized( this.compartments )
				{
					CompartmentDynamics result = this.compartments
							.get( compartment );
					if( result == null )
					{
						result = CompartmentDynamics.of( getSpace(),
								getInfection(), compartment );
						this.compartments.put( compartment, result );
					}
					return result;
				}
			}
		}
	}

	/**
	 * {@link CompartmentDynamics}
	 * 
	 * @version $Id$
	 * @author Rick van Krevelen
	 */
	interface CompartmentDynamics
	{
		TransmissionSpace getSpace();

		Infection getInfection();

		EpidemicCompartment getCompartment();

		Map<Carrier, Instant> getArrivals();

		VisitorDynamics dynamicsOf( Carrier visitor );

		default void onEnter( final Carrier visitor )
		{
			final Instant previous;
			if( (previous = getArrivals().put( visitor,
					getSpace().now() )) != null )
				throw ExceptionFactory.createUnchecked(
						"%s already entered {} on {}", visitor, getSpace(),
						previous );

			if( getCompartment().isInfective() )
			{

				//  TODO update force of infection as f(R0, D) and reschedule (advance)
				// pending transmissions, or cancel on prior departure

				//Map< Individual, >
//				final Amount<Duration> duration = null;
//				final Amount<Frequency> force = getInfection()
//						.getForceOfInfection( this, visitor,
//								getLocation().per( getInfection() )
//										.per( EpidemicCompartment.Simple.SUSCEPTIBLE )
//										.getArrivals().keySet(),
//								duration );
			}
		}

		default void onLeave( final Carrier visitor )
		{
			final Instant arrival;
			if( (arrival = getArrivals().remove( visitor )) == null )
				throw ExceptionFactory.createUnchecked( "{} already left {}",
						visitor, getSpace() );
			arrival.toAmount();
//			final Instant departure = getLocation().now();
//			for( Map.Entry<Individual, Instant> entry : getOccupantArrivals()
//					.entrySet() )
//			{
//				final Instant start = arrival.compareTo( entry.getValue() ) > 0
//						? arrival : entry.getValue();
//				final Duration overlap = Duration.between( start, departure );
//
//				// FIXME generate contact events from overlapping occupancy/vector infestation/contamination stays
//				// FIXME generate transmission events
//			}
		}

		static CompartmentDynamics of( final TransmissionSpace space,
			final Infection infection, final EpidemicCompartment compartment )
		{
			return new Simple( space, infection, compartment );
		}

		/**
		 * {@link Simple} implementation of {@link CompartmentDynamics}
		 * 
		 * @version $Id$
		 * @author Rick van Krevelen
		 */
		class Simple implements CompartmentDynamics
		{
			private final TransmissionSpace space;

			private final Infection infection;

			private final EpidemicCompartment compartment;

			private final Map<Carrier, Instant> visitorArrivals = new ConcurrentSkipListMap<>();

			private final Map<Carrier, VisitorDynamics> visitorDynamics = new ConcurrentSkipListMap<>();

			public Simple( final TransmissionSpace space,
				final Infection infection,
				final EpidemicCompartment compartment )
			{
				this.space = space;
				this.infection = infection;
				this.compartment = compartment;
			}

			@Override
			public TransmissionSpace getSpace()
			{
				return this.space;
			}

			@Override
			public Infection getInfection()
			{
				return this.infection;
			}

			@Override
			public EpidemicCompartment getCompartment()
			{
				return this.compartment;
			}

			@Override
			public Map<Carrier, Instant> getArrivals()
			{
				return this.visitorArrivals;
			}

			@Override
			public VisitorDynamics dynamicsOf( final Carrier visitor )
			{
				synchronized( this.visitorDynamics )
				{
					VisitorDynamics result = this.visitorDynamics
							.get( visitor );
					if( result == null )
					{
						final Amount<Frequency> rate = null;
						result = VisitorDynamics.of( visitor, Accumulator.of(
								getSpace().scheduler(), Amount.ZERO, rate ) );
						this.visitorDynamics.put( visitor, result );
					}
					return result;
				}
			}
		}
	}

	/**
	 * {@link VisitorDynamics}
	 * 
	 * @version $Id$
	 * @author Rick van Krevelen
	 */
	interface VisitorDynamics
	{
		Carrier getVisitor();

		Accumulator<Dimensionless> getAccumulator();

		/**
		 * @param visitor the {@link Carrier} visiting
		 * @param accumulator the {@link Accumulator}
		 * @return a {@link Simple} instance of {@link VisitorDynamics}
		 */
		static VisitorDynamics of( final Carrier visitor,
			final Accumulator<Dimensionless> accumulator )
		{
			return new Simple( visitor, accumulator );
		}

		/**
		 * {@link Simple} implementation of {@link VisitorDynamics}
		 * 
		 * @version $Id$
		 * @author Rick van Krevelen
		 */
		class Simple implements VisitorDynamics
		{
			private Carrier visitor;

			private Accumulator<Dimensionless> accumulator;

			public Simple( final Carrier visitor,
				final Accumulator<Dimensionless> accumulator )
			{
				this.visitor = visitor;
				this.accumulator = accumulator;
			}

			@Override
			public Carrier getVisitor()
			{
				return this.visitor;
			}

			@Override
			public Accumulator<Dimensionless> getAccumulator()
			{
				return this.accumulator;
			}
		}
	}
}
